<html>
<head>
  <title>Программирование - Быстрое преобразование Фурье</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="../css/styles2.css">
</head>
<body>
 <div id=hdr>
  <div id=psi></div>
  <div id=l1></div><div id=l2></div><div id=l3></div><div id=l4></div>
  <div id=capt2>Оптимизация поворачивающих<br>множителей</div>
 </div>
<div id=body>
  <div id=mi><a href="fft4.htm">[предыдущая глава]</a>&nbsp;&nbsp;<a href="fft.htm">[оглавление]</a>&nbsp;&nbsp;<a href="fft6.htm">[следующая глава]</a></div>
<div id=text>

<p>

В приведенной выше программе велико искушение для вычисления поворачивающих множителей
использовать формулу:

<p>

<img align="absmiddle" src="image179.gif">.&nbsp;&nbsp;&nbsp;&nbsp;(17)

<p>

Это позволило бы избавиться от возведений в степень и обойтись одними
умножениями, если заранее вычислить <nobr>W<sub>N</sub></nobr> для
<nobr>N&nbsp;=&nbsp;2,&nbsp;4,&nbsp;8,…,&nbsp;Nmax</nobr>. Но то, что можно делать
в математике, далеко не всегда можно делать в программах. По мере увеличения
<nobr>k</nobr> поворачивающий множитель будет изменяться, но вместе с тем
<i>будет расти погрешность</i>. Ведь вычисления с плавающей точкой на реальном
компьютере совсем без погрешностей невозможны. И после <nobr>N/2</nobr> подряд
умножений в поворачивающем множителе может накопиться огромное отклонение
от точного значения. Вспомним правило: при умножении величин их относительные
погрешности складываются. Так что, если погрешность одного умношения равна
<nobr>s%</nobr>, то после <nobr>1000</nobr> умножений она может достигнуть в худшем случае
<nobr>1000s%</nobr>.

<p>

Этого можно было бы избежать, будь число <nobr>W<sub>N</sub></nobr> целым, но оно 
не целое при <nobr>N&nbsp;&gt;&nbsp;2</nobr>, так как вычисляется через синус и косинус:

<p>

<img align="absmiddle" src="image184.gif">

<p>

Как же избежать множества обращений к весьма медленным функциям синуса и
косинуса? Здесь нам приходит на помощь давно известный алгоритм вычисления
степени через многократные возведения в квадрат и умножения. Например:

<p>

<img align="absmiddle" src="image186.gif">

<p>

В данном случае нам понадобилось всего <nobr>5</nobr> умножений (учитывая, что
<sub><img src="image188.gif"></sub> не нужно вычислять
дважды) вместо <nobr>13</nobr>. В худшем случае для возведения в степень от <nobr>1</nobr>
до <nobr>N/2-1</nobr> нужно <nobr>log<sub>2</sub>N</nobr>
умножений вместо <nobr>N/2</nobr>, что дает вполне приемлемую погрешность
для большинства практических задач.

<p>

Можно сократить вдвое количество умножений на каждом шаге, если
использовать результаты прошлых вычислений
<p>

<img align="absmiddle" src="image192.gif">,

<p>

для хранения которых нужно дополнительно <nobr>log<sub>2</sub>(Nmax)</nobr>
комплексных ячеек памяти:

<p>

<img align="absmiddle" src="image196.gif">

<p>

Если очередное <sub><img src="image059.gif"></sub> не было вычислено
предварительно, то берется двоичное представление <nobr>k</nobr> и анализируется.
Каждому единичному биту соответствует ровно один множитель. В общем случае
единице в бите с номером <nobr>b</nobr> (младший бит имеет номер <nobr>0</nobr>) соответствует
множитель <sub><img src="image200.gif"></sub>, который хранится
в <nobr>b</nobr>-й ячейке упомянутого выше массива.

<p>

Есть способ уменьшить количество умножений для вычисления
<sub><img src="image059.gif"></sub> до одного на два цикла. Но для
этого нужно отвести <nobr>N</nobr><nobr>/2</nobr> комплексных ячеек для хранения всех
предыдущих <sub><img src="image059.gif"></sub>. Алгоритм достаточно
прост. Нечетные элементы вычисляются по формуле (17). Четные вычисляются по
формуле:

<p>

<img align="absmiddle" src="image204.gif">

<p>

То есть, ничего не вычисляется, а берется одно из значений, вычисленных
на предыдущем шаге, когда <nobr>N</nobr> было вдвое меньше. Чтобы не нужно было
копировать величины на новые позиции достаточно их сразу располагать в той
позиции, которую они займут при <nobr>N = Nmax</nobr> и вводить простую поправку
<nobr>Skew</nobr> (см. <a href="fft6.htm">листинг программы</a>).

<p>

И последние пояснения относительно листинга.

<p>

Во-первых, здесь присутствует реализация простейших операций над комплексными
числами (классы Complex и ShortComplex), оптимизированная под
данную задачу. Обычно та или иная реализация уже есть для многих компиляторов,
так что можно использовать и ее.

<p>

Во-вторых, массив <nobr>W2</nobr><nobr>n</nobr> содержит заранее вычисленные коэффициенты
<nobr>W<sub>2</sub>, W<sub>4</sub>, W<sub>8</sub>,...,W<sub>Nmax</sub></nobr>.

<p>

В-третьих, для вычислений используются наиболее точное представление чисел
с плавающей точкой в C++: long double размером в 10 байт на платформе Intel.
Для хранения результатов в массивах используется тип double длиной 8 байт.
Причина - не в желании сэкономить 20% памяти, а в том, что 64-битные и
32-битные процессоры лучше работают с выровненными по границе 8 байт данными,
чем с выровненными по границе 10 байт.

  <div id=mi>
   <hr size=1 noshade color=black>
   <a href="fft4.htm">[предыдущая глава]</a>&nbsp;&nbsp;<a href="fft.htm">[оглавление]</a>&nbsp;&nbsp;<a href="fft6.htm">[следующая глава]</a>
   <hr size=1 noshade color=black>
  </div>
 </div>
</body>
</html>
