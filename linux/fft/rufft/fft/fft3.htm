<html>
<head>
  <title>Программирование - Быстрое преобразование Фурье</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="../css/styles2.css">
</head>
<body>
 <div id=hdr>
  <div id=psi></div>
  <div id=l1></div><div id=l2></div><div id=l3></div><div id=l4></div>
  <div id=capt2>Алгоритм предварительной<br>перестановки</div>
 </div>
<div id=body>
  <div id=mi><a href="fft2.htm">[предыдущая глава]</a>&nbsp;&nbsp;<a href="fft.htm">[оглавление]</a>&nbsp;&nbsp;<a href="fft4.htm">[следующая глава]</a></div>
<div id=text>

<p>

Теперь рассмотрим конкретную реализацию БПФ. Пусть имеется
<nobr>N=2<sup>T</sup></nobr> элементов последовательности
<nobr>x<sub>{N}</sub></nobr> и надо получить последовательность <nobr>X<sub>{N}</sub></nobr>.
Прежде всего, нам придется разделить <nobr>x<sub>{N}</sub></nobr>
на две последовательности: четные и нечетные элементы. Затем точно так же
поступить с каждой последовательностью. Этот итерационный процесс закончится,
когда останутся последовательности длиной по 2 элемента. Пример процесса для
<nobr>N=16</nobr> показан ниже:

<p>

<img align="absmiddle" src="image146.gif">

<p>

Итого выполняется <nobr>(log<sub>2</sub>N)-1</nobr> итераций.

<p>

Рассмотрим двоичное представление номеров элементов и занимаемых ими мест.
Элемент с номером 0 (двоичное 0000) после всех перестановок занимает позицию 0
(0000), элемент 8 (1000) - позицию 1 (0001), элемент 4 (0100) - позицию 2
(0010), элемент 12 (1100) - позицию 3 (0011). И так далее. Нетрудно заметить
связь между двоичным представлением позиции до перестановок и после всех
перестановок: они зеркально симметричны. Двоичное представление конечной
позиции получается из двоичного представления начальной позиции перестановкой
битов в обратном порядке. И наоборот.

<p>

Этот факт не является случайностью для конкретного <nobr>N=16</nobr>, а является
закономерностью. На первом шаге четные элементы с номером <nobr>n</nobr>
переместились в позицию <nobr>n/2</nobr>, а нечетные из позиции в позицию
<nobr>N/2+(n-1)/2</nobr>. Где <nobr>n=0,1,…,N-1</nobr>. Таким образом, новая позиция
вычисляется из старой позиции с помощью функции:

<p>

<nobr>ror(n,N) = [n/2] + N{n/2}</nobr>

<p>

Здесь как обычно <nobr>[x]</nobr> означает целую часть числа, а <nobr>{x}</nobr> - дробную.

<p>

В ассемблере эта операция называется <i>циклическим сдвигом вправо (ror)</i>,
если <nobr>N</nobr> - это степень двойки. Название операции происходит из того факта,
что берется двоичное представление числа <nobr>n</nobr>, затем все биты, кроме
младшего (самого правого) перемещаются на 1 позицию вправо. А младший бит
перемещается на освободившееся место самого старшего (самого левого) бита.

<p>

<img align="absmiddle" src="image151.gif">
<br>рис. 1

<p>

Дальнейшие разбиения выполняются аналогично. На каждом следующем шаге
количество последовательностей удваивается, а число элементов в каждой из них
уменьшается вдвое. Операции <nobr>ror</nobr> подвергаются уже не все биты, а только
несколько младших (правых). Старшие же <nobr>j-1</nobr> битов остаются нетронутыми
(зафиксированными), где <nobr>j</nobr> - номер шага:

<p>

<img align="absmiddle" src="image152.gif">
<br>рис. 2

<p>

Что происходит с номерами позиций при таких последовательных операциях?
Давайте проследим за произвольным битом номера позиции. Пусть этот бит
находился в <nobr>j</nobr>-м двоичном разряде, если за 0-й разряд принять самый
младший (самый правый). Бит будет последовательно сдвигаться вправо на каждом
шаге до тех пор, пока не окажется в самой правой позиции. Это случится после
<nobr>j</nobr>-го шага. На следующем, <nobr>j+1</nobr>-м шаге будет зафиксировано <nobr>j</nobr>
 старших битов и тот бит, за которым мы следим, переместится в разряд с номером
<nobr>T-j-1</nobr>. После чего окажется зафиксированным и останется на месте. Но
именно такое перемещение - из разряда <nobr>j</nobr> в разряд <nobr>T-j-1</nobr> и
необходимо для зеркальной перестановки бит. Что и требовалось доказать.

<p>

Теперь, мы убедились в том, что перестановка элементов действительно
осуществляется по принципу, при котором в номерах позиций происходит
в свою очередь другая перестановка: зеркальная перестановка двоичных
разрядов. Это позволит нам получить простой алгоритм:

<p>

<pre>
for(I = 1; I < N-1; I++)
{
    J = reverse(I,T);           // reverse переставляет биты в I в обратном порядке
    if (I >= J)                     // пропустить уже переставленные
        conitnue;
    S = x[I]; x[I] = x[J]; x[J] = S;  // перестановка элементов xI и xJ
}
</pre>

<p>

Некоторую проблему представляет собой операция обратной перестановки бит
номера позиции reverse(), которая не реализована ни в популярной архитектуре
Intel, ни в наиболее распространенных языках программирования. Приходится
реализовывать ее через другие битовые операции. Ниже приведен алгоритм
функции перестановки <nobr>T</nobr> младших битов в числе <nobr>I</nobr>:

<p>

<pre>
unsigned int reverse(unsigned int I, int T)
{
    int Shift = T - 1;
    unsigned int LowMask = 1;
    unsigned int HighMask = 1 << Shift;
    unsigned int R;
    for(R = 0; Shift >= 0; LowMask <<= 1, HighMask >>= 1, Shift -= 2)
        R |= ((I & LowMask) << Shift) | ((I & HighMask) >> Shift);
    return R;
}
</pre>

<p>

Пояснения к алгоритму. В переменных <nobr>LowMask</nobr> и <nobr>HighMask</nobr> хранятся
маски, выделяющие два переставляемых бита. Первая маска в двоичном
представлении выглядит как 0000…001 и в цикле изменяется, сдвигая единицу каждый
раз на <nobr>1</nobr> разряд влево:

<p>

<pre>
0000...001
0000...010
0000...100
...
</pre>

<p>

Вторая маска (<nobr>HighMask</nobr>) принимает последовательно значения:

<p>

<pre>
1000...000
0100...000
0010...000
..., 
</pre>

<p>

каждую итерацию сдвигая единичный бит на <nobr>1</nobr> разряд вправо. Эти два сдвига
осуществляются инструкциями <nobr>LowMask&nbsp;&lt;&lt;=&nbsp;1</nobr> и
<nobr>HighMask&nbsp;&gt;&gt;=&nbsp;1</nobr>. 

<p>

Переменная <nobr>Shift</nobr> показывает расстояние (в разрядах) между
переставляемыми битами. Сначала оно равно <nobr>T-1</nobr> и каждую итерацию
уменьшается на <nobr>2</nobr>. Цикл прекращается, когда расстояние становится меньше или
равно нулю.

<p>

Операция <nobr>I&nbsp;&amp;&nbsp;LowMask</nobr> выделяет первый бит, затем он сдвигается на
место второго (<nobr>&lt;&lt;Shift</nobr>). Операция <nobr>I&nbsp;&amp;&nbsp;HighMask</nobr> выделяет
второй бит, затем он сдвигается на место первого (&gt;&gt;<nobr>Shift</nobr>). После
чего оба бита записываются в переменную <nobr>R</nobr> операцией "|".
<p>

Вместо того чтобы переставлять биты позиций местами, можно применить и другой
метод. Для этого надо вести отсчет <nobr>0,1,2,…,N/2-1</nobr> уже с обратным
следованием битов. Опять-таки, ни в ассемблере Intel, ни в распространенных
языках программирования не реализованы операции над обратным битовым
представлением. Но алгоритм приращения на единицу известен, и его можно
реализовать программно. Вот пример для <nobr>T=4</nobr>.

<p>

<pre>
I = 0;
J = 0;
for(J1 = 0; J1 < 2; J4++, J ^= 1)
    for(J2 = 0; J2 < 2; J3++, J ^= 2)
        for(J4 = 0; J4 < 2; J4++, J ^= 4)
            for(J8 = 0; J8 < 2; J8++, J ^= 8)
            {
                if (I < J)
                {
                    S = x[I]; x[I] = x[J]; x[J] = S;  // перестановка элементов xIи xJ
                }
                I++;
            }
</pre>

<p>

В этом алгоритме используется тот общеизвестный факт, что при увеличении числа
от 0 до бесконечности (с приращением на единицу) каждый бит меняется с 0 на 1
и обратно с определенной периодичностью: младший бит - каждый раз, следующий -
каждый второй раз, следующий - каждый четвертый и так далее.

<p>

Эта периодичность реализована в виде <nobr>T</nobr> вложенных циклов, в каждом из
которых один из битов позиции <nobr>J</nobr> переключается туда и обратно с помощью
операции XOR (В C/C++ она записывается как ^=). Позиция <nobr>I</nobr> использует
обычный инкремент <nobr>I++</nobr>, уже встроенный в язык программирования.

<p>

Данный алгоритм имеет тот недостаток, что требует разного числа вложенных циклов
в зависимости от <nobr>T</nobr>. На практике это не очень плохо, поскольку <nobr>T</nobr>
обычно ограничено некоторым разумным пределом (16..20), так что можно написать
столько вариантов алгоритма, сколько нужно. Тем не менее, это делает программу
громоздкой. Ниже я предлагаю вариант этого алгоритма, который эмулирует
вложенные циклы через стеки <nobr>Index</nobr> и <nobr>Mask</nobr>.

<p>                

<pre>
int Index[MAX_T];
int Mask[MAX_T];
int R;
for(I = 0; I < T; I++)
{
    Index[I] = 0;
    Mask[I] = 1 << (T - I - 1);
}
 
J = 0;
 
for(I = 0; I < N; I++)
{
    if (I < J)
    {
        S = x[I]; x[I] = x[J]; x[J] = S;  // перестановка элементов xI и xJ
    }
    for(R = 0; R < T; R++)
    {
        J ^= Mask[R];
        if (Index[R] ^= 1)  // эквивалентно Index[R] ^= 1; if (Index[R] != 0)
            break;
    }
}
</pre>

<p>

Величина <nobr>MAX_T</nobr> определяет максимальное значение для <nobr>T</nobr> и в
наихудшем случае равна разрядности целочисленных переменных ЭВМ. Этот алгоритм,
может быть, чуть медленнее, чем предыдущий, но дает экономию по объему кода.

<p>

И, наконец, последний алгоритм. Он использует классический подход к
многоразрядным битовым операциям: надо разделить 32-бита на 4 байта,
выполнить перестановку в каждом из них, после чего переставить сами байты.
<p>

Перестановку бит в одном байте уже можно делать по таблице. Для нее нужно
заранее приготовить массив <nobr>reverse256</nobr> из 256 элементов. Этот массив
будет содержать 8-битовые числа. Записываем туда числа от <nobr>0</nobr> до <nobr>255</nobr> и
переставляем в каждом порядок битов.

<p>

Теперь этот массив применим для последней реализации функции reverse:

<pre>
unsigned int reverse(unsigned int I, int T)
{
    unsigned int R;
    unsigned char *Ic = (unsigned char*) &I;
    unsigned char *Rc = (unsigned char*) &R;
    Rc[0] = reverse256[Ic[3]];
    Rc[1] = reverse256[Ic[2]];
    Rc[2] = reverse256[Ic[1]];
    Rc[3] = reverse256[Ic[0]];
    R >>= (32 - T);
    Return R;
}
</pre>

<p>

Обращения к массиву <nobr>reverse256</nobr> переставляют в обратном порядке биты в
каждом байте. Указатели <nobr>Ic</nobr> и <nobr>Ir</nobr> позволяют обратиться к отдельным
байтам 32-битных чисел <nobr>I</nobr> и <nobr>R</nobr> и переставить в обратном порядке
байты. Сдвиг числа <nobr>R</nobr> вправо в конце алгоритма устраняет различия между
перестановкой <nobr>32</nobr> бит и перестановкой <nobr>T</nobr> бит. Ниже приводится наглядная
геометрическая иллюстрация алгоритма, где стрелками показаны перестановки
битов, байтов и сдвиг.

<p>

<img align="absmiddle" src="image154.gif">
<br>рис. 3

<p>

Оценим сложность описанных алгоритмов. Понятно, что все они пропорциональны
<nobr>N</nobr> с каким-то коэффициентом. Точное значение коэффициента зависит от
конкретной ЭВМ. Во всех случаях мы имеем <nobr>N</nobr> перестановок со сравнением
<nobr>I</nobr> и <nobr>J</nobr>, которое предотвращает повторную перестановку некоторых
элементов. Рядом присутствует некоторый обрамляющий код, применяющий
достаточно быстрые операции над целыми числами: присваивания, сравнения,
индексации, битовые операциии и условные переходы. Среди них в архитектуре
Intel наиболее накладны переходы. Поэтому я бы рекомендовал последний алгоритм.
Он содержит всего <nobr>N</nobr> переходов, а не <nobr>2N</nobr> как в алгоритме со
вложенными циклами или их эмуляцией и не <nobr>NT</nobr> как в самом первом
алгоритме. 

<p>

С другой стороны, предварительная перестановка занимает мало времени по
сравнению с последующими операциями, использующими
<nobr>(N/2)log<sub>2</sub>N</nobr> умножений комплексных
чисел. В таком случае тоже есть смысл выбрать не самый короткий, но самый
простой и наглядный алгоритм - последний описанный. Вот его окончательный
вид с небольшой оптимизацией:

<p>

<pre>
static unsigned char reverse256[]= {
    0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0,
    0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
    0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8,
    0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
    0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4,
    0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
    0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC,
    0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
    0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2,
    0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
    0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA,
    0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
    0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6,
    0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
    0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE,
    0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
    0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1,
    0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
    0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9,
    0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
    0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5,
    0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
    0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED,
    0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
    0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3,
    0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
    0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB,
    0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
    0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7,
    0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
    0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF,
    0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF,
};
 
 
unsigned int I, J;
unsigned char *Ic = (unsigned char*) &I;
unsigned char *Jc = (unsigned char*) &J;
 
for(I = 1; I < N - 1; I++)
{
    Jc[0] = reverse256[Ic[3]];
    Jc[1] = reverse256[Ic[2]];
    Jc[2] = reverse256[Ic[1]];
    Jc[3] = reverse256[Ic[0]];
    J >>= (32 - T);
    if (I < J)
    {
        S = x[I];
        x[I] = x[J];
        x[J] = S;
    }
}
</pre>

  <div id=mi>
   <hr size=1 noshade color=black>
   <a href="fft2.htm">[предыдущая глава]</a>&nbsp;&nbsp;<a href="fft.htm">[оглавление]</a>&nbsp;&nbsp;<a href="fft4.htm">[следующая глава]</a>
   <hr size=1 noshade color=black>
  </div>
 </div>
</body>
</html>
