<html>
<head>
  <title>Программирование - Быстрое преобразование Фурье</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="../css/styles2.css">
</head>
<body>
 <div id=hdr>
  <div id=psi></div>
  <div id=l1></div><div id=l2></div><div id=l3></div><div id=l4></div>
  <div id=capt2>БПФ для произвольного N</div>
 </div>
<div id=body>
  <div id=mi><a href="fft9.htm">[предыдущая глава]</a>&nbsp;&nbsp;<a href="fft.htm">[оглавление]</a>&nbsp;&nbsp;<a href="fftb.htm">[следующая глава]</a></div>
<div id=text>

<p>

Ранее мы рассмотрели случаи, когда число элементов преобразования равно степени двойки. К сожалению, на данный момент
не существует столь же эффективного алгоритма вычисления ДПФ для произвольного <nobr>N</nobr>. Однако, существует 
алгоритм, который значительно лучше "лобового" решения задачи. Он требует, чтобы <nobr>N</nobr> было четным. Допустим,
что <nobr>N = M 2<sup>T</sup> = M L</nobr>. Число <nobr>L</nobr> - целая степень двойки, числа <nobr>M</nobr> и
<nobr>T</nobr> - положительные целые. 

<p>

Сложность этого алгоритма равна <nobr>N<sup>2</sup> / L + Nlog<sub>2</sub>L</nobr>. Как видите, этот алгоритм тем 
эффективнее, чем больше <nobr>L</nobr>, то есть, чем больше число элементов <nobr>N</nobr> "похоже" на степень двойки.
В худшем случае, когда <nobr>L = 2</nobr>, он лишь немногим лучше "лобового" решения, которое имеет сложность 
<nobr>N<sup>2</sup></nobr>. 

<p>

Тем не менее, на практике нам часто полезен именно описанный алгоритм. Допустим, у нас имеется оцифрованный звуковой 
сигнал, длиной в 2001 отсчет, и мы хотим узнать его спектр. Если мы применим обычный алгоритм, то нам придется 
отрезать "лишний" кусок сигнала, размером почти в его половину, уменьшив число отсчетов до 1024. Но в таком случае мы потеряем гармоники, которые, 
возможно, возникли только ближе к концу сигнала.  Другой вариант: дополнить исходный сигнал до 2048 отсчетов - тоже плох. В
самом деле: чем его дополнить? Если нулями, то в результате мы приобретем множество лишних гармоник из-за резкого 
скачка сигнала вниз на 2001-м отсчете. Совершенно неясно, как интерполировать сигнал на дополнительные 47 отсчетов так,
чтобы не появились новые, ненужные гармоники (шумы). И только новый алгоритм решает эту проблему. С помощью него мы
можем "отрезать" совсем небольшой кусочек, в 1 отсчет, взяв <nobr>L = 16</nobr> и получив ускорение в 16 раз! Либо
мы можем пожертвовать кусочком чуть длиннее, взяв <nobr>L</nobr> еще больше. Для реальных сигналов невелика вероятность, 
что на этом маленьком отрезке спектр резко изменится, так что результат получится вполне удовлетворительный.

<p>

Теперь рассмотрим сам алгоритм. Его главной частью является уже знакомый нам алгоритм "fft" для <nobr>N</nobr>, равного
степени двойки. Этот алгоритм лишь немного модифицирован. Из исходной последовательности длиной <nobr>N</nobr>
выбирается <nobr>L</nobr> элементов, начиная от элемента с номером <nobr>h (0 &le; h < M)</nobr> и с шагом <nobr>M</nobr>. В
результате получается последовательность из <nobr>L</nobr> элементов. Так как <nobr>L</nobr> у нас - степень двойки,
мы можем применить к полученной последовательности обычный алгоритм БПФ. Результаты преобразования записываются в
те же ячейки, откуда были взяты. Изменение алгоритма заключается всего лишь в том, что каждый раз вместо 
<nobr>g</nobr>-го элемента берется элемент с номером <nobr>h + gM</nobr>, то есть, выполняется замена индексов по
формуле:

<p>

<nobr>g &rarr; h + gM</nobr>&nbsp;&nbsp;&nbsp;&nbsp;(38)

<p>

Позднее мы еще дополнительно оптимизируем этот алгоритм, а пока выпишем его результат в виде формулы:

<p>

<img align=absmiddle src="image042.gif">&nbsp;&nbsp;&nbsp;&nbsp;(39)

<p>

Где <nobr>g = 0, 1,..., L - 1</nobr>.
Как видите, по сравнению с формулой (1) мы выполнили замену переменных: <nobr>k &rarr; g, n &rarr; l, N &rarr; L</nobr> и сделали
преобразование индексов по формуле (38). 

<p>

На первом этапе модифицированный алгоритм БПФ применяется ко всем элементам исходной последовательности. Для этого
вычисление по формуле (38) выполняется для <nobr>h = 0, 1,..., M - 1</nobr>. Каждое такое вычисление меняет 
<nobr>L</nobr> элементов с индексами <nobr>h, h + M, h + 2M,..., h + (L - 1)M</nobr>. Таким образом, вызвав 
<nobr>M</nobr> раз этот алгоритм, мы изменим все <nobr>N = ML</nobr> элементов заданной последовательности:

<p>
<br>Шаг 0: элементы с номерами <nobr>0, M, 2M, ... (L-1)M</nobr>
<br>Шаг 1: элементы с номерами <nobr>1, 1 + M, 1 + 2M, ... 1 + (L-1)M</nobr>
<br>Шаг 2: элементы с номерами <nobr>2, 2 + M, 2 + 2M, ... 2 + (L-1)M</nobr>
<br>...
<br>Шаг M-1: элементы с номерами <nobr>M - 1, M - 1 + M, M - 1 + 2M, ... M - 1 + (L-1)M</nobr>

<p>

На втором этапе заводится новый массив размером в <nobr>N</nobr> элементов, и к нему применяется формула:

<p>

<img align=absmiddle src="image038.gif">&nbsp;&nbsp;&nbsp;&nbsp;(40)

<p>

В двойном цикле величина <nobr>s</nobr> проходит значения <nobr>0..M - 1</nobr>, а величина <nobr>r</nobr> проходит 
значения <nobr>0..L - 1</nobr>. Общее число итераций, таким образом, равно <nobr>ML = N</nobr>. Каждая итерация требует 
суммирования <nobr>M</nobr> элементов. То есть, общее количество слагаемых равно <nobr>NM</nobr>.
На предварительном этапе мы <nobr>M</nobr> раз применили обычный алгоритм БПФ для <nobr>L</nobr> элементов, который, 
как мы уже знаем, имеет сложность <nobr>L log<sub>2</sub>L</nobr>. Таким образом, общая сложность алгоритма
равна:

<p>

<nobr>NM + L log<sub>2</sub>L = N(N/L) + ML log<sub>2</sub>L = N<sup>2</sup>/L + N log<sub>2</sub>L</nobr>.

<p>

Тем самым, мы доказали формулу сложности, приведенную в начале главы.

<p>

Теперь нам осталось доказать только то, что формула (40) действительно дает ДПФ. Для этого подставим формулу
(39) в формулу (40):

<p>

<img src="image040.gif">

<p>

... поскольку выражение <sub><sub><img src="image044.gif"></sub></sub> не зависит от <nobr>l</nobr>, то мы
его можем внести под знак внутренней суммы:

<p>

<img src="image046.gif">

<p>

... теперь учтем, что <nobr>L = N/M</nobr>, чтобы привести выражение в показателе степени к общему знаменателю и упростить:

<p>

<img src="image048.gif">

<p>

... теперь воспользуемся Теоремой 0, чтобы добавить полезный множитель, равный единице:

<p>

<img src="image049.gif">

<p>

... теперь воспользуемся равенством <nobr>N = ML</nobr>, чтобы разбить сумму в числителе на множители:

<p>

<img src="image050.gif">

<p>

... теперь выполним замену переменных <nobr>r + sL &rarr; k, m + lM &rarr; n</nobr>:

<p>

<img src="image051.gif">

<p>

Эта сумма эквивалентна сумме (1), с точностью до перемены мест слагаемых. В самом деле, если
<nobr>n = m + lM, m = 0..M - 1, l = 0..L - 1, N = LM</nobr>, то переменная <nobr>n</nobr> по мере суммирования
принимает все значения от <nobr>0</nobr> до <nobr>N - 1</nobr> ровно по одному разу. Что и требовалось доказать.

  <div id=mi>
   <hr size=1 noshade color=black>
   <a href="fft9.htm">[предыдущая глава]</a>&nbsp;&nbsp;<a href="fft.htm">[оглавление]</a>&nbsp;&nbsp;<a href="fftb.htm">[следующая глава]</a>
   <hr size=1 noshade color=black>
  </div>
 </div>
</body>
</html>
