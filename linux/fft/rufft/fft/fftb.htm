<html>
<head>
  <title>Программирование - Быстрое преобразование Фурье</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="../css/styles2.css">
</head>
<body>
 <div id=hdr>
  <div id=psi></div>
  <div id=l1></div><div id=l2></div><div id=l3></div><div id=l4></div>
  <div id=capt2>Пояснения и оптимизация</div>
 </div>
<div id=body>
  <div id=mi><a href="ffta.htm">[предыдущая глава]</a>&nbsp;&nbsp;<a href="fft.htm">[оглавление]</a>&nbsp;&nbsp;<a href="fftc.htm">[следующая глава]</a></div>
<div id=text>

<p>

Настало время написать и оптимизировать алгоритм. Посмотрите на <a href="fft6.htm">исходный алгоритм "fft"</a> и
на <a href="fftc.htm">алгоритм для случая четного N "fft2"</a>. 

<p>

Здесь мы рассмотрим листинг "fft2" сверху вниз, комментируя все детали.

<p>

Сверху вы видите фрагмент, совпадающий со старым листингом вплоть до <nobr>#define M_2PI</nobr>. Этот макрос
определяет константу <nobr>2&pi;</nobr>.

<p>

Функция <nobr>complex_mul</nobr> выполняет умножение комплексных чисел <nobr>z1</nobr> и <nobr>z2</nobr> и записывает
результат в ячейку <nobr>z</nobr>. 

<p>

Мы собираемся вызывать алгоритм "fft" <nobr>M</nobr> раз для одного и того же числа элементов <nobr>L</nobr>. 
Для оптимизации мы должны вынести за пределы алгоритма "fft" те действия, которые не зависят от выбора конкретных 
элементов в массиве.

<p>

К таким действиям можно отнести выделение памяти для хранения поворачивающих множителей и освобождение ее.
Деление результата на <nobr>N</nobr> также можно выполнить позже для всего массива сразу. А главное, мы можем всего
лишь однажды вычислить все поворачивающие множители. Для решения этой задачи мы напишем отдельную функцию
<nobr>createWstore</nobr>, которая и вычисляет множители, и выделает массив ячеек памяти для них. Позднее этот 
массив будет передаваться как параметр в новый вариант алгоритма "fft".

<p>

Функция <nobr>createWstore</nobr> представляет собой ту часть основного цикла "fft", которая отвечала за рассчет
поворачивающих множителей. Однако, она оптимизирована. Число итераций меньше, чем в исходном алгоритме, 
поскольку не на всех итерациях выполнялось вычисление нового множителя, иногда происходило только копирование. 
Поэтому шаг приращений индекса в массиве вдвое больше: <nobr>Skew2</nobr> вместо <nobr>Skew</nobr>. 
Переменная <nobr>k</nobr> для определения четности/нечетности нам больше не нужна, так что внутренний цикл 
останавливается при достижении границы массива <nobr>WstoreEnd</nobr>. 

<p>

Порядок вычисления множителей <sub><img src="image052.gif"></sub> будет понятнее на примере. Если 
<nobr>L = 32</nobr>, то порядок изменения <nobr>k</nobr> такой (точкой с запятой разделены итерации внешнего цикла,
а запятой - внутреннего):

<p><nobr>k = 0; 16; 8, 24; 4, 12, 20, 28; 2, 6, 10, 14, 18, 22, 26; 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23...31</nobr>

<p>

Далее, вместо старого алгоритма "fft" мы напишем новый - "fft_step" с учетом того, что поворачивающие множители 
считать не надо, и не надо делить результат на <nobr>N</nobr>. 

<p>

Сам алгоритм практически не изменился за исключением того, что все расстояния между элементами
массива увеличились в <nobr>M</nobr> раз, согласно формуле (38). Приставка "M" перед именами 
новых переменных означает умножение на <nobr>M</nobr>.

<p>

На вход этой функции будет передаваться массив со смещением. Тем самым происходит коррекция индекса 
на <nobr>+h</nobr> элементов, согласно формуле (38).

<p>

В основной функции сначала анализируется параметр <nobr>N</nobr>. Если он нечетный, то мы вынуждены отсечь
один элемент (последний) и уменьшить <nobr>N</nobr> на единицу.	Таким образом, на входе алгоритма требуется
<nobr>N &ge; 2</nobr>.

<p>

Далее вычисляется <nobr>L</nobr> как максимальная степень двойки, кратная <nobr>N</nobr>, сама эта степень
<nobr>T</nobr> и величина <nobr>M</nobr>. 

<p>

Затем вычисляются поворачивающие множители для "fft_step" и вызывается сам "fft_step" нужное число раз. Если
оказывается, что <nobr>N</nobr> является степенью двойки, то сработает обычный "fft".

<p>

Следующим шагом мы вычисляем поворачивающие коэффициенты уже для формулы (40). Этот фрагмент алгоритма очень
похож на <nobr>createWstore</nobr>, поэтому в дополнительных комментариях не нуждается. Результат оказывается
в массиве <nobr>mult</nobr>. 

<p>

Далее вычисляется формула (40). Смысл переменных: <nobr>pX</nobr> - указатель на <nobr>X<sub>r+sL</sub></nobr>;
<nobr>rpsL = r + sL</nobr>; <nobr>mprM = m + rM</nobr>; <nobr>one</nobr> - очередное слагаемое суммы (40).

<p>

Величина <nobr>widx</nobr> равна остатку от деления <nobr>m(r + sL)</nobr> на <nobr>N</nobr>. Таким способом
мы избегаем выхода за границы массива <nobr>mult</nobr>. Это можно делать, благодаря Теореме 1 - ведь 
поворачивающие множители как раз имеют период <nobr>N</nobr>.

<p>

Еще можно заметить, что в сумме (40) в первом множителе поворачивающий коэффициент всегда равен <nobr>1</nobr>,
благодаря чему мы экономим несколько умножений.

<p>

И наконец, происходит корректировка результатов для обратного ДПФ делением на <nobr>N</nobr>.

<p>

Функция БПФ для четного <nobr>N</nobr> называется "fft2".

  <div id=mi>
   <hr size=1 noshade color=black>
   <a href="ffta.htm">[предыдущая глава]</a>&nbsp;&nbsp;<a href="fft.htm">[оглавление]</a>&nbsp;&nbsp;<a href="fftc.htm">[следующая глава]</a>
   <hr size=1 noshade color=black>
  </div>
 </div>
</body>
</html>
