<html>
<head>
  <title>Программирование - Быстрое преобразование Фурье</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="../css/styles2.css">
</head>
<body>
 <div id=hdr>
  <div id=psi></div>
  <div id=l1></div><div id=l2></div><div id=l3></div><div id=l4></div>
  <div id=capt2>Практические советы и замечания</div>
 </div>
<div id=body>
  <div id=mi><a href="fftf.htm">[предыдущая глава]</a>&nbsp;&nbsp;<a href="fft.htm">[оглавление]</a>&nbsp;&nbsp;<b>[следующая глава]</b></div>
<div id=text>

	<p>
	<b>Как выполнить преобразование на практике</b>
<p>

Берем сигнал длительностью <nobr>T</nobr>, разбиваем его на <nobr>N - 1</nobr> частей, получаем мгновенные значения сигнала
в <nobr>N</nobr> точках:

<p>

<img src="image000.gif">
		
<p>

Если есть возможность выбрать <nobr>N</nobr>, то следует выбрать степень двойки, так как соответствующий 
алгоритм немного быстрее. Если нет возможности выбрать, то не страшно - все равно есть алгоритм, не такой быстрый, но тоже
имеющий сложность <nobr>N log<sub>2</sub>N</nobr>.
	
<p>

Далее, создаем массив комплексных чисел, длиной <nobr>N</nobr>:

<pre>
    ShortComplex arr[N];
</pre>

<p>

Теперь заполняем его. Допустим исходный сигнал у нас в массиве <nobr>x</nobr>, и это действительная величина. Тогда
просто копируем <nobr>x</nobr> в реальную часть элементов в массиве <nobr>arr</nobr>, а мнимую часть обнуляем:

<pre>
    for(int i= 0; i < N; ++i)
    {
        arr[i].re= x[i];
        arr[i].im= 0.0;
    }
</pre>

<p>

Теперь осталось применить алгоритм БПФ. Если <nobr>N = 2<sup>k</sup></nobr> - т.е. степень двойки, то используем 
соответствующий алгоритм <a href="fft6.htm">отсюда</a>:

<pre>
    fft(arr, k, false);
</pre>
	
<p>

Если же мы не можем гарантировать, что <nobr>N</nobr> - степень двойки, тогда используем универсальный 
алгоритм <a href="fftf.htm">отсюда</a>:

<pre>
    universal_fft(arr, N, false);
</pre>
	
<p>

После исполнения этой функции массив <nobr>arr</nobr> изменится и будет теперь содержать результат
прямого преобразования Фурье. 

<p>

Для обратного преобразования надо вызвать ту же функцию с последним аргументом <nobr>true</nobr>.
Если нужна действительная функция <nobr>x</nobr>, то надо будет еще скопировать массив обратно, отбрасывая
мнимую часть:

<pre>
    universal_fft(arr, N, true);

    for(int i= 0; i < N; ++i)
        x[i]= arr[i].re;
</pre>

	<p>
	<b>Наглядное представление</b>
		
<p>
	
Полученный результат представляет собой последовательность комплексных чисел в форме пар: 
(реальная часть, мнимая часть). Но для понимания физической структуры сигнала желательно
преобразовать их в амплитуды, частоты и фазы гармоник. 

<p>

Для преобразования можно
использовать формулы:

<p>

<img src="image031.gif">

<p>

Самый первый элемент с индексом <nobr>0</nobr> показывает постоянную составляющую сигнала, 
то есть, насколько он в среднем "приподнят" над осью времени. Остальные элементы представляют
гармоники вида <nobr>A cos(2&pi;&nu;t + &phi;)</nobr>, где <nobr>&nu;</nobr> - это частота,
которая для гармоники с индексом <nobr>k</nobr> будет равна:

<p>

<nobr>&nu; = k / T</nobr>
	
<p>

Часто бывает дано не суммарное время сигнала <nobr>T</nobr>, а частота дискретизации:
сколько отсчетов приходится на одну секунду. Обозначим ее <nobr>S</nobr>.
Тогда частота для гармоники с индексом <nobr>k</nobr> будет равна:

<p>

<nobr>&nu; = S	k / N</nobr>

<p>

В сумме постоянная составляющая и все гармоники должны дать исходный сигнал.

<p>

Также по ходу дела можно исправить <a href="fft8.htm">зеркальный эффект</a>. Если 
взять сигнал, который состоит из единственной гармоники с частотой <nobr>f > 0</nobr> 
и выполнить прямое дискретное преобразования Фурье, то в полученном спектре обнаружатся
два ненулевых элемента, соответствующих частотам <nobr>f</nobr> и <nobr>f' = (N / T - f)</nobr>, где <nobr>N</nobr> - число точек
дискретного преобразования Фурье, <nobr>T</nobr> - длительность отрезка, для которого выполнено преобразование. Оба элемента
имеют половинные амплитуды по сравнению с исходной гармоникой.

<p>
	
Для устранения зеркального эффекта можно просто обнулить вторую половину спектра с индексами после <nobr>N / 2</nobr>,
а все элементы первой половины помножить на <nobr>2</nobr>. При этом не надо умножать самый первый элемент с индексом
<nobr>0</nobr>, который соответствует частоте <nobr>0</nobr>, то есть постоянной составляющей.

<p>

В процессе преобразования могут возникнуть ошибки округления, из-за которых появятся ненулевые элементы
там, где должен быть ноль. Если мы хотим устранить этот эффект, нужно задать некоторый нижний предел
и отбрасывать гармоники с амплитудами меньше этого предела.
	
<p>

И, наконец, последний штрих: функция синуса которая начинается от нуля, может оказаться 
нагляднее, чем функция косинуса. Поэтому есть смысл представить гармоники в виде
синусов: <nobr>A sin(2&pi;&nu;t + &phi;)</nobr>, только для этого придется сместить фазу
на <nobr>&pi;/2</nobr>.

<p>

В результате алгоритм получения наглядного представления будет таким:

<pre>
    //Это комплексные числа, результат прямого дискретного преобразования Фурье
    //ShortComplex - это структура с полями: double re, im;
    ShortComplex arr[N];
	
    //это индекс комплексного числа в массиве arr
    int i;

    //это частота дискретизации
    double nSamplesPerSec;

    //убираем зеркальный эффект, просто отбрасывая вторую половину
    int Nmax= (N + 1) / 2; 

    //мы хотим получить массив гармоник.
    //это массив амплитуд, массив частот и массив фаз для каждой гармоники
    double *freq= new double[Nmax];
    double *amp= new double[Nmax];
    double *phase= new double[Nmax];
	
    //это индекс гармоники. в конце алгоритма он будет равен количеству найденных гармоник
    int j= 0;

    //это нижний предел амплитуды гармоники. тут может быть число больше нуля
    //в зависимости от того, какие амплитуды мы считаем ничтожно малыми.
    double limit= 0.001;
    
    //вспомогательная переменная для оптимизации
    double abs2min= limit * limit * N * N;
	
    //получаем постоянную составляющую
    if (arr[i]->re >= limit)
    {
        amp[j]= arr[i].re / N;
		freq[j]= 0.0;
		phase[j]= 0.0;
		++j;
    }
    ++i;

    //получаем остальные гармоники
    for(i= 1; i < Nmax; ++i)
    {
        double re= arr[i].re;
        double im= arr[i].im;
		
        //это квадрат модуля комплексного числа arr[i]
        double abs2= re * re + im * im;
		
        //отбрасываем слишком слабые гармоники
        if (abs2 < abs2min)
            continue;
		
        //вычисляем апмлитуду. 2.0 - для устранения зеркального эффекта
        amp[j]= 2.0 * sqrt(abs2) / N;
		
		//вычисляем фазу косинуса в радианах
        phase[j]= atan2(im, re);

        //преобразуем косинус в синус. M_PI2 = пи/2, M_PI = пи
		//в результате фаза будет в диапазоне от -пи/2 до +пи/2
        phase[j]+= M_PI2;
        if (phase[j] > M_PI)
            phase[j]-= M_2PI;
		
        //можно еще преобразовать радианы в градусы
        phase[j]= phase[j] * 180.0 / M_PI;
		
		//получаем частоту
        freq[j]= (nSamplesPerSec * i) / N;
		
        ++j;
    }
	
</pre>

<p>

Получив список частот, фаз и амплитуд, можно воспользоваться какой-нибудь программой, чтобы построить график 
или таблицу. Например, в очередной версии программы Bard, которую я сейчас пишу, это выглядит так:

<p>

<img src="image214.png">
	
<p>
	<b>Преобразование туда и обратно</b>
<p>	
Если выполнить прямое, а потом обратное преобразование Фурье, то должны получиться те же самые числа
с небольшими отклонениями из-за неизбежных ошибок округления. В частности, если исходная 
последовательность была действительной (мнимые части равны нулю), то после прямого преобразования Фурье
могут появиться ненулевые мнимые части, но после обратного преобразования они снова обнулятся.

<p>
	
Однако, если после прямого преобразования внести изменения в массив и потом выполнить обратное преобразование, то могут
появиться элементы с ненулевыми мнимыми частями. Если вы применяете преобразования Фурье для обработки
действительных сигналов, эти ненулевые мнимые части надо просто игнорировать.

<p>

В частности, если вы исправляете зеркальный эффект, вы (после прямого преобразование) обнуляете элементы 
с индексами выше <nobr>N / 2</nobr> и удваиваете элементы с индексами от <nobr>1</nobr> до <nobr>N / 2</nobr>.
Если теперь выполнить обратное преобразование, то реальная часть сигнала останется прежней, но мнимая
часть сигнала станет ненулевой. Ее можно проигнорировать.

<p>
	<b>Эффект размазывания</b>
<p>	
	
Данный эффект <a href="fft9.htm">подробно расматривался ранее</a>, а здесь приведен среди других эффектов.
Если частота исходной гармоники не равна в точности дной из частот <nobr>k/T</nobr>, то вместо
одной линии спектра получится смазанный пик - тем более смазанный, чем дальше отстоит
исходная частота от ближайшей частоты <nobr>k/T</nobr>.

<p>

<img src="image215.png">
	
<p>

Здесь зеленым показана амплитуда спектральных гармоник, фиолетовым - фаза (как видите,
в районе нужной частоты она делает резкий скачок). Исходной гармоникой здесь было
колебание с амплитудой 30000, фазой 0 и частотой 440,2 Гц. Время дискретизации 
<nobr>T</nobr> было равно 1 секунде при разбиении на 44100 отрезков. Ближайшие частоты 
вида <nobr>k/T</nobr> равны 440 и 441 Гц, для них никакого размазывания не было бы.

<p>

В англоязычной литературе этот эффект называется smearing (размазывание) или leakage (рассеяние).
Это связано с тем, что мощность исходной гармоники как бы рассеивается. Если вы посмотрите на 
предыдущую иллюстрацию, то увидите, что высота пика не дотягивает до правильной отметки в 30000,
но вместе с дополнительными линиями, окружающими пик, мощность получается такой, как нужно.

<p>
	<b>Эффекты модуляции</b>
<p>	

А вот эта картинка - 

<p>	

<img src="image216.png">

<p>
	
- получена совсем другим способом. Здесь была гармоника 440 Гц,
но ее амплитуда в течение секунды линейно затухала от 30000 до 0. Картинки очень похожи,
так что пойди разбери - то ли причина размазывания в том, что гармоника не попала точно 
в величину <nobr>k/T</nobr>, то ли в том, что было затухание во времени.

<p>	

Различие там есть, просто оно не видно на картинке. При непопадании на
<nobr>k/T</nobr> фаза максимальной гармоники приблизительно совпадает с фазой 
одной из двух соседник гармоник и сильно отличается от фазы другой. А при 
модуляции фазы соседних гармоник или совпадают, или обе сильно отличаются
от фазы максимальной. Чтобы показать это, на следующей паре картинок фаза и 
амплитуда отмечены не вертикальными рисками, а крестиками:

<p>	

<img src="image221.png"><img src="image222.png">

<p>	

На левой картинке - размазывание от несовпадения частот, на правой - от затухания.
Так что в целом для различения этих случаев можно применять критерий: если
фаза максимальной гармоники где-то посредине между фазами соседних гармоник,
то это - модуляция, а если фаза максимальной гармоники гораздо близка к одной
из "соседок", то это - несовпадение частот.

<p>	

Вот еще картинка:

<p>	

<img src="image218.png">

<p>
	
- здесь амплитуда линейно затухала от 30000 до 15000.

<p>	

<img src="image217.png">

<p>
	
- здесь амплитуда <u>не</u>линейно нарастала от 0 до 30000.

<p>	

<img src="image219.png">

<p>
	
- эта скромная картинка получена с добавлением пульсации: амплитуда синусоидально увеличивается-уменьшается
10 раз за секунду. Две дополнительные частоты по бокам от основной обеспечили пульсацию основной частоты.

<p>	

<img src="image220.png">

<p>
	
- а здесь все то же самое, но пульсация не 10 раз в секунду, а чуть-чуть медленнее. В секунду не уложилось целое
число пульсаций, так что возник эффект размазывания вокруг дополнительных частот.

<p>	

<img src="image223.png">

<p>
	
- наконец, вот этот хаос возникает в результате "вибрато" - то есть, периодического изменения не амплитуды,
а частоты. В данном случае на периоде 0.8 секунд произошло 8 периодических изменений частоты на четверть
тона.


  <div id=mi>
   <hr size=1 noshade color=black>
   <a href="fftf.htm">[предыдущая глава]</a>&nbsp;&nbsp;<a href="fft.htm">[оглавление]</a>&nbsp;&nbsp;<b>[следующая глава]</b></a>
   <hr size=1 noshade color=black>
  </div>
 </div>
</body>
</html>
